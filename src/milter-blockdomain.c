/******************************************************************************/
/*                                                                            */
/*  milter-blockdomain.c                                                      */
/*                                                                            */
/*  Copyright(C) 2016, Takao Abe.  All rights reserved.                       */
/*                                                                            */
/*  LICENSE: GPLv3 or any later version                                       */
/*                                                                            */
/*  This program is free software: you can redistribute it and/or modify      */
/*  it under the terms of the GNU General Public License as published by      */
/*  the Free Software Foundation, either version 3 of the License, or         */
/*  (at your option) any later version.                                       */
/*                                                                            */
/*  This program is distributed in the hope that it will be useful,           */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                      */
/*  See the GNU General Public License for more details.                      */
/*                                                                            */
/*  You should have received a copy of the GNU General Public License         */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.     */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Web:    http://www.bea.hi-ho.ne.jp/abetakao/milter-blockdomain/           */
/*  Email:  HCA00763@nifty.ne.jp  or  takao_abe@xurb.jp                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  C programming language standard : C99                                     */
/*  Typical compile command/options :                                         */
/*          cc -std=gnu99 -Wall -D_GNU_SOURCE -c file.c                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  ChangeLog                                                                 */
/*                                                                            */
/*  2016/05/21  1.00                                                          */
/*      First release                                                         */
/*                                                                            */
/*  2016/07/02  1.01                                                          */
/*      [Enhancement] Support GNU build procedure.                            */
/*                    Add config.h generated by the Autoconf/Automake.        */
/*      [Enhancement] Conf file new keyword 'syslogDebug'.                    */
/*                    Optional writing syslog priority=debug.                 */
/*      [Enhancement] Conf file new keyword 'checkMacro_'.                    */
/*                    Check value of the sendmail macro '_'.                  */
/*      [Change] Return SMFIS_CONTINUE when smfi_getpriv returns NULL for     */
/*               the private data pointer.                                    */
/*                                                                            */
/*  2016/11/03  1.02                                                          */
/*      [Bug fix] Lost the first entry of unsorted domain list.               */
/*                Patched: blkdom_config.c - addDomain                        */
/*                                                                            */
/*  2018/01/13  1.04                                                          */
/*      [Change] Return previous TEMPFAIL or REJECT check result in the       */
/*               SMTP session preferentially.                                 */
/*               Add debug log when the mlfi_xxxx's return.                   */
/*               milter-blockdomain.c                                         */
/*                                                                            */
/*                                                                            */
/*  2022/04/30  1.05                                                          */
/*      [Enhancement] Command line option -t                                  */
/*                    Minimum interval of checking domain list file update.   */
/*      [Enhancement] Statistics information to syslog daily.                 */
/*                    Command line option -s for hourly statistics info.      */
/*      [Add] README.md                                                       */
/*                                                                            */
/******************************************************************************/

#include "config.h"	/* GNU Autotools */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <getopt.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pwd.h>

#include <libmilter/mfapi.h>

#include "milter-blockdomain.h"

/* Constant */

#ifdef PACKAGE_NAME
static	const	char	*PROGRAM_NAME    = PACKAGE_NAME ;
#else
static	const	char	*PROGRAM_NAME    = "milter-blockdomain" ;
#endif

#ifdef PACKAGE_VERSION
static	const	char	*PROGRAM_VERSION = PACKAGE_VERSION ;
#else
static	const	char	*PROGRAM_VERSION = "1.NN" ;
#endif

#ifdef PACKAGE_DATE
static	const	char	*PROGRAM_DATE    = PACKAGE_DATE ;
#else
static	const	char	*PROGRAM_DATE    = "YYYY-MM-DD" ;
#endif

#ifndef BUILD_TIMESTAMP
#define	BUILD_TIMESTAMP	"YYYY-MM-DD HH:MM TZ"
#endif

static	const	char	*STRING_NULL_MARK = "(*NULL*)" ;

/* Typedef */

typedef struct stringListStruct
{
	char	*pString ;
	int 	checkResult ;
	struct	stringListStruct *pNext ;
} stringListType ;

typedef struct
{
	char	*connectAddr ;
	char	*connectFrom ;
	char	*reverseLookup ;
	char	*heloFrom ;
	char	*envFrom ;
	stringListType	*envRcptList ;
	bool	bHeaderStart ;
	bool	bBodyStart ;
	int 	checkResult ;
} privateDataType ;

/* Local data */

static	char	*sConfFile = "/etc/mail/milter-blockdomain.conf" ;
static	char	bDaemon = TRUE ;

static	time_t	iMinimumInterval ;
static	time_t	tLastUpdateCheck ;

static	struct {
	uint	iCheckFile ;
	uint	iSkipFile  ;
	uint	iAccpet    ;
	uint	iTempfail  ;
	uint	iReject    ;
	uint	iUnmatch   ;
} vStatCount ;

struct  tm      tmStatLog ;

static  bool    bHourlyStatLog ;    /* FALSE: Daily | TRUE: Hourly */

/* External data */

extern	confType xConfData ;

/* Function prototype */

static sfsistat mlfi_connect( SMFICTX *, char *, _SOCK_ADDR * ) ;
static sfsistat mlfi_helo   ( SMFICTX *, char * ) ;
static sfsistat mlfi_envfrom( SMFICTX *, char ** ) ;
static sfsistat mlfi_envrcpt( SMFICTX *, char ** ) ;
static sfsistat mlfi_header ( SMFICTX *, char *, char * ) ;
static sfsistat mlfi_eoh    ( SMFICTX * ) ;
static sfsistat mlfi_body   ( SMFICTX *, unsigned char *, size_t ) ;
static sfsistat mlfi_eom    ( SMFICTX * ) ;
static sfsistat mlfi_abort  ( SMFICTX * ) ;
static sfsistat mlfi_close  ( SMFICTX * ) ;
static sfsistat mlfi_unknown( SMFICTX *, const char * ) ;
static sfsistat mlfi_data   ( SMFICTX * ) ;
static sfsistat mlfi_negotiate( SMFICTX *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long *, unsigned long *, unsigned long *, unsigned long * ) ;

static sfsistat mlfi_cleanup( SMFICTX * ) ;

static int setFileCheckInterval( const char * ) ;

/* Local macro */

#define MAX(a, b)	( (a) > (b) ? (a) : (b) )

/**************************************************************************************************/

struct smfiDesc smfilter =
{
	"milter-blockdomain",   /* filter name */
	SMFI_VERSION,           /* version code -- do not change */
	SMFIF_ADDHDRS|SMFIF_ADDRCPT,	/* flags */
	mlfi_connect,   /* connection info filter */
	mlfi_helo,      /* SMTP HELO command filter */
	mlfi_envfrom,   /* envelope sender filter */
	mlfi_envrcpt,   /* envelope recipient filter */
	mlfi_header,    /* header filter */
	mlfi_eoh,       /* end of header */
	mlfi_body,      /* body block filter */
	mlfi_eom,       /* end of message */
	mlfi_abort,     /* message aborted */
	mlfi_close,     /* connection cleanup */
	mlfi_unknown,   /* unknown SMTP commands */
	mlfi_data,      /* DATA command */
	mlfi_negotiate  /* Once, at the start of each SMTP connection */
};

/**************************************************************************************************/

static void
milterLog( privateDataType *pPrivateData, const char *pCheckPoint, int iCheckResult )
{

	const	char	*pRevLookup, *pRevLookupName, *pIPaddress, *pHelo, *pEnvFrom, *pEnvRcpt ;
	const	char	*pResult ;

	stringListType	*pEnvrcptEntry ;

	if ( pPrivateData->connectAddr == NULL ) pIPaddress = STRING_NULL_MARK ;
	else                                     pIPaddress = pPrivateData->connectAddr ;

	if ( pPrivateData->reverseLookup == NULL && pPrivateData->connectFrom == NULL ) {
		pRevLookupName = STRING_NULL_MARK ;
		pRevLookup = "(Unsolved)" ;
	} else if ( pPrivateData->reverseLookup == NULL ) {
		pRevLookupName = pPrivateData->connectFrom ;
		if ( *pRevLookupName == '['  ) pRevLookup = "(Unsolved)" ;
		else                           pRevLookup = "(Solved)" ;
	} else if ( strcmp( pPrivateData->reverseLookup, STRING_NULL_MARK ) == 0 ) {
		pRevLookupName = pPrivateData->connectFrom ;
		if ( *pRevLookupName == '['  ) pRevLookup = "(Unsolved)" ;
		else                           pRevLookup = "(Solved)" ;
	} else {
		pRevLookupName = pPrivateData->reverseLookup ;
		if ( *pRevLookupName == '['  ) {
			pRevLookup = "(Unsolved)" ;
		} else if ( strcmp( pRevLookupName, pPrivateData->connectFrom ) == 0 ) {
			pRevLookup = "(Solved)" ;
		} else {
			pRevLookup = "(Forged)" ;
		}
	}

	if ( xConfData.bTestMode ) {
		switch ( iCheckResult ) {
		case RC_NOTLISTED : pResult = "TestMode(NOTLISTED)" ; break ;
		case RC_WHITELIST : pResult = "TestMode(ACCEPT)"    ; break ;
		case RC_BLACKLIST : pResult = "TestMode(REJECT)"    ; break ;
		case RC_GREYLIST  : pResult = "TestMode(TEMPFAIL)"  ; break ;
		default           : pResult = "TestMode(UNKNOWN)"   ; break ;
		}
	} else {
		switch ( iCheckResult ) {
		case RC_NOTLISTED : pResult = "NOTLISTED" ; break ;
		case RC_WHITELIST : pResult = "ACCEPT"    ; break ;
		case RC_BLACKLIST : pResult = "REJECT"    ; break ;
		case RC_GREYLIST  : pResult = "TEMPFAIL"  ; break ;
		default           : pResult = "UNKNOWN"   ; break ;
		}
	}

	if ( pPrivateData->heloFrom == NULL ) pHelo = STRING_NULL_MARK ;
	else                                  pHelo = pPrivateData->heloFrom ;

	if ( pPrivateData->envFrom == NULL ) pEnvFrom = STRING_NULL_MARK ;
	else                                 pEnvFrom = pPrivateData->envFrom ;

	pEnvrcptEntry = pPrivateData->envRcptList ;
	while ( pEnvrcptEntry != NULL ) {
		if ( pEnvrcptEntry->checkResult != RC_NOTLISTED ) break ;
		pEnvrcptEntry = pEnvrcptEntry->pNext ;
	}
	if      ( pEnvrcptEntry          == NULL ) pEnvRcpt = STRING_NULL_MARK ;
	else if ( pEnvrcptEntry->pString == NULL ) pEnvRcpt = STRING_NULL_MARK ;
	else                                       pEnvRcpt = pEnvrcptEntry->pString ;

	logInfo( "%s %s [%s]: %s, %s: HELO=%s FROM=%s RCPT=%s",
	         pRevLookup, pRevLookupName, pIPaddress, pResult, pCheckPoint,
	         pHelo, pEnvFrom, pEnvRcpt ) ;

}

/**************************************************************************************************/

static int
checkBlockList( privateDataType *pPrivateData, const int iCheckPoint )
{

	int 	rc ;
	stringListType	*envRcpt ;

	if ( xConfData.bDebugCheckFunction ) logDebug( "%s: iCheckPoint=%d", __func__, iCheckPoint ) ;

	if (   iCheckPoint <  CHECKPOINT_HEADER
	  || ( iCheckPoint == CHECKPOINT_HEADER && pPrivateData->bHeaderStart == FALSE )
	  || ( iCheckPoint == CHECKPOINT_BODY   && pPrivateData->bBodyStart   == FALSE ) ) {

		if ( xConfData.bCheckConnect
		  && iCheckPoint == MAX( xConfData.iCheckOnAndAfter, CHECKPOINT_CONNECT ) ) {

			rc = checkConnect( pPrivateData->connectFrom ) ;

			if ( rc != RC_NOTLISTED ) {
				milterLog( pPrivateData, "CONNECT", rc ) ;
				if ( xConfData.bTestMode ) rc = RC_WHITELIST ;
				return rc ;
			}

		}

		if ( xConfData.bCheckMacro_
		  && iCheckPoint == MAX( xConfData.iCheckOnAndAfter, CHECKPOINT_CONNECT ) ) {

			rc = checkConnect( pPrivateData->reverseLookup ) ;

			if ( rc != RC_NOTLISTED ) {
				milterLog( pPrivateData, "CONNECT", rc ) ;
				if ( xConfData.bTestMode ) rc = RC_WHITELIST ;
				return rc ;
			}

		}

		if ( xConfData.bCheckHelo
		  && iCheckPoint == MAX( xConfData.iCheckOnAndAfter, CHECKPOINT_HELO ) ) {

			rc = checkHelo( pPrivateData->heloFrom ) ;

			if ( rc != RC_NOTLISTED ) {
				milterLog( pPrivateData, "HELO", rc ) ;
				if ( xConfData.bTestMode ) rc = RC_WHITELIST ;
				return rc ;
			}

		}

		if ( xConfData.bCheckEnvFrom
		  && iCheckPoint == MAX( xConfData.iCheckOnAndAfter, CHECKPOINT_ENVFROM ) ) {

			rc = checkEnvFrom( pPrivateData->envFrom ) ;

			if ( rc != RC_NOTLISTED ) {
				milterLog( pPrivateData, "FROM", rc ) ;
				if ( xConfData.bTestMode ) rc = RC_WHITELIST ;
				return rc ;
			}

		}

		if ( xConfData.bCheckEnvRcpt
		  && iCheckPoint == MAX( xConfData.iCheckOnAndAfter, CHECKPOINT_ENVRCPT ) ) {

			for ( envRcpt = pPrivateData->envRcptList ; envRcpt != NULL ; envRcpt = envRcpt->pNext ) {

				rc = checkEnvRcpt( envRcpt->pString ) ;

				if ( rc != RC_NOTLISTED ) {
					envRcpt->checkResult = rc ;
					milterLog( pPrivateData, "RCPT", rc ) ;
					if ( xConfData.bTestMode ) rc = RC_WHITELIST ;
					return rc ;
				}

			}

		}

	}

	return RC_NOTLISTED ;

}

/**************************************************************************************************/

static sfsistat
mlfi_cleanup( SMFICTX *ctx )
{

	stringListType	*pRecipient ;
	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		return SMFIS_TEMPFAIL ;
	}

	/* release private memory */
	if ( pPrivateData->connectAddr   != NULL ) free( pPrivateData->connectAddr ) ;
	if ( pPrivateData->connectFrom   != NULL ) free( pPrivateData->connectFrom ) ;
	if ( pPrivateData->reverseLookup != NULL ) free( pPrivateData->reverseLookup ) ;
	if ( pPrivateData->heloFrom      != NULL ) free( pPrivateData->heloFrom ) ;
	if ( pPrivateData->envFrom       != NULL ) free( pPrivateData->envFrom    ) ;
	while ( pPrivateData->envRcptList != NULL ) {
		pRecipient = pPrivateData->envRcptList ;
		pPrivateData->envRcptList = pRecipient->pNext ;
		if ( pRecipient->pString != NULL ) free( pRecipient->pString ) ;
		free( pRecipient ) ;
	}
	free( pPrivateData ) ;

	/* clear the private data pointer */
	smfi_setpriv( ctx, NULL ) ;

	/* return status */
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_connect( SMFICTX *ctx, char *hostname, _SOCK_ADDR *hostaddr )
{

	privateDataType *pPrivateData ;
	char	sHostAddr[ INET_ADDRSTRLEN ], sHostAddr6[ INET6_ADDRSTRLEN ] ;
	const	char	*pHostAddr = NULL ;

	char	*ident ;
	int 	i, iLength, iPosSpace, iPosBrace ;
	int 	rc ;

	time_t  tNow ;
	struct  tm  tmNow ;

    /* Statistics log */

    tNow = time( NULL ) ;
    localtime_r( &tNow, &tmNow ) ;

	if ( tmStatLog.tm_mon != tmNow.tm_mon || tmStatLog.tm_mday != tmNow.tm_mday
	  || ( bHourlyStatLog && tmStatLog.tm_hour != tmNow.tm_hour ) ) {

	logInfo( "Statistics: CheckFile=%u SkipFile=%u AcceptCount=%u TempfailCount=%u RejectCount=%u UnmatchCount=%d",
	         vStatCount.iCheckFile, vStatCount.iSkipFile, vStatCount.iAccpet, vStatCount.iTempfail, vStatCount.iReject, vStatCount.iUnmatch ) ;

		tmStatLog.tm_year = tmNow.tm_year ;
		tmStatLog.tm_mon  = tmNow.tm_mon  ;
		tmStatLog.tm_mday = tmNow.tm_mday ;
		tmStatLog.tm_hour = tmNow.tm_hour ;
		tmStatLog.tm_min  = tmNow.tm_min  ;
		tmStatLog.tm_sec  = tmNow.tm_sec  ;

	}

	/* allocate some private memory */
	pPrivateData = (privateDataType*) malloc( sizeof(privateDataType) ) ;
	if ( pPrivateData == NULL ) {
		/* can't accept this message right now */
		logAlert( ALERT_MESSAGE_MALLOC_NULL, __func__ ) ;
		return SMFIS_TEMPFAIL;
	}
	memset( pPrivateData, 0, sizeof(privateDataType) ) ;
	pPrivateData->checkResult = RC_NOTLISTED ;
	pPrivateData->bHeaderStart = FALSE ;
	pPrivateData->bBodyStart = FALSE ;

	/* save the private data */
	rc = smfi_setpriv( ctx, pPrivateData ) ;
	if ( rc != MI_SUCCESS ) {
		logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setpriv" ) ;
		free( pPrivateData ) ;
		return SMFIS_TEMPFAIL;
	}

	/* Host address */
	if ( hostaddr != NULL ) {
		switch ( hostaddr->sa_family ) {
		case AF_INET :
			pHostAddr = inet_ntop( AF_INET, &(((const struct sockaddr_in *)hostaddr)->sin_addr), sHostAddr, sizeof(sHostAddr) ) ;
			if ( pHostAddr == NULL ) logError( ERROR_MESSAGE_INET_NTOP ) ;
			break ;
		case AF_INET6 :
			pHostAddr = inet_ntop( AF_INET6, &(((const struct sockaddr_in6 *)hostaddr)->sin6_addr), sHostAddr6, sizeof(sHostAddr6) ) ;
			if ( pHostAddr == NULL ) logError( ERROR_MESSAGE_INET_NTOP ) ;
			break ;
		default :
			logError( ERROR_MESSAGE_UNKNOWN_AF ) ;
			break ;
		}
		pPrivateData->connectAddr = strdup( pHostAddr ) ;
		if ( pPrivateData->connectAddr == NULL ) {
			logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
			mlfi_cleanup( ctx ) ;
			return SMFIS_TEMPFAIL ;
		}
	}

	/* Hostname */
	pPrivateData->connectFrom = strdup( hostname ) ;
	if ( pPrivateData->connectFrom == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	/* Reverse lookup name */
	ident = smfi_getsymval( ctx, "_" ) ;
	if ( ident == NULL ) {
		pPrivateData->reverseLookup = strdup( STRING_NULL_MARK ) ;
	} else if ( *ident == '[' ) {
		pPrivateData->reverseLookup = strdup( ident ) ;
	} else {
		iLength = strlen( ident ) ;
		iPosSpace = iPosBrace = iLength ;
		for ( i = 0 ; i < iLength ; i ++ ) {
			if ( ident[i] == ' ' && i < iPosSpace ) iPosSpace = i ;
			if ( ident[i] == '[' && i < iPosBrace ) iPosBrace = i ;
		}
		if ( iLength == 0 || iPosSpace == 0 ) {
			pPrivateData->reverseLookup = strdup( STRING_NULL_MARK ) ;
		} else {
			pPrivateData->reverseLookup = strdup( ident ) ;
		}
		if ( pPrivateData->reverseLookup != NULL ) {
			if ( iPosSpace < iLength && iPosBrace < iLength && iPosSpace + 1 == iPosBrace ) {
				pPrivateData->reverseLookup[iPosSpace] = 0 ;
			}
		} 
	}
	if ( pPrivateData->reverseLookup == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: Macro(_)=%s", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr, pPrivateData->reverseLookup ) ;

	/* Check domain list update */
	if ( tNow - tLastUpdateCheck >= iMinimumInterval ) {
		vStatCount.iCheckFile ++ ;
		tLastUpdateCheck = tNow ;
		if ( ReloadAllDomainList() == RC_ERROR ) {
			if ( smfi_setreply( ctx, "451", "4.7.1", xConfData.sMessageTempfail ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			mlfi_cleanup( ctx ) ;
			return SMFIS_TEMPFAIL ;
		}
	} else {
		vStatCount.iSkipFile ++ ;
	}

	/* Check domain block list */
	if ( xConfData.bCheckConnect && CHECKPOINT_CONNECT >= xConfData.iCheckOnAndAfter ) {

		if ( pPrivateData->checkResult == RC_NOTLISTED || pPrivateData->checkResult == RC_WHITELIST ) {
			pPrivateData->checkResult = checkBlockList( pPrivateData, CHECKPOINT_CONNECT ) ;
		}

		switch ( pPrivateData->checkResult ) {
		case RC_WHITELIST :
			vStatCount.iAccpet ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_ACCEPT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_ACCEPT ;
		case RC_BLACKLIST :
			if ( smfi_setreply( ctx, "554", "5.7.1", xConfData.sMessageReject ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iReject ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_REJECT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_REJECT ;
		case RC_GREYLIST  :
			if ( smfi_setreply( ctx, "451", "4.7.1", xConfData.sMessageTempfail ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iTempfail ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_TEMPFAIL", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_TEMPFAIL ;
		default :
			vStatCount.iUnmatch ++ ;
			break ;
		}

	}

	/* continue processing */
	logDebug( "%s: %s [%s]: return SMFIS_CONTINUE", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_helo( SMFICTX *ctx, char *helohost )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* helo, ehlo */
	if ( helohost == NULL ) {
		pPrivateData->heloFrom = strdup( STRING_NULL_MARK ) ;
	} else {
		pPrivateData->heloFrom = strdup( helohost ) ;
	}
	if ( pPrivateData->heloFrom == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: HELO=%s", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr, pPrivateData->heloFrom ) ;

	/* Check domain block list */
	if ( xConfData.bCheckHelo && CHECKPOINT_HELO >= xConfData.iCheckOnAndAfter ) {

		if ( pPrivateData->checkResult == RC_NOTLISTED || pPrivateData->checkResult == RC_WHITELIST ) {
			pPrivateData->checkResult = checkBlockList( pPrivateData, CHECKPOINT_HELO ) ;
		}

		switch ( pPrivateData->checkResult ) {
		case RC_WHITELIST :
			vStatCount.iAccpet ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_ACCEPT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_ACCEPT ;
		case RC_BLACKLIST :
			if ( smfi_setreply( ctx, "554", "5.7.1", xConfData.sMessageReject ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iReject ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_REJECT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_REJECT ;
		case RC_GREYLIST  :
			if ( smfi_setreply( ctx, "451", "4.7.1", xConfData.sMessageTempfail ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iTempfail ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_TEMPFAIL", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_TEMPFAIL ;
		default :
			vStatCount.iUnmatch ++ ;
			break ;
		}

	}

	/* continue processing */
	logDebug( "%s: %s [%s]: return SMFIS_CONTINUE", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_envfrom( SMFICTX *ctx, char **argv )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Envelope from */
	if ( argv[0] == NULL ) {
		pPrivateData->envFrom = strdup( STRING_NULL_MARK ) ;
	} else {
		pPrivateData->envFrom = strdup( argv[0] ) ;
	}
	if ( pPrivateData->envFrom == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: EnvFROM=%s", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr, pPrivateData->envFrom ) ;

	/* Check domain block list */
	if ( xConfData.bCheckEnvFrom && CHECKPOINT_ENVFROM >= xConfData.iCheckOnAndAfter ) {

		if ( pPrivateData->checkResult == RC_NOTLISTED || pPrivateData->checkResult == RC_WHITELIST ) {
			pPrivateData->checkResult = checkBlockList( pPrivateData, CHECKPOINT_ENVFROM ) ;
		}

		switch ( pPrivateData->checkResult ) {
		case RC_WHITELIST :
			vStatCount.iAccpet ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_ACCEPT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_ACCEPT ;
		case RC_BLACKLIST :
			if ( smfi_setreply( ctx, "554", "5.7.1", xConfData.sMessageReject ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iReject ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_REJECT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_REJECT ;
		case RC_GREYLIST  :
			if ( smfi_setreply( ctx, "451", "4.7.1", xConfData.sMessageTempfail ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iTempfail ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_TEMPFAIL", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_TEMPFAIL ;
		default :
			vStatCount.iUnmatch ++ ;
			break ;
		}

	}

	/* continue processing */
	logDebug( "%s: %s [%s]: return SMFIS_CONTINUE", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_envrcpt( SMFICTX *ctx, char **argv )
{

	stringListType	*pRecipient ;
	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Envelope recipient */
	pRecipient = (stringListType*) malloc( sizeof(stringListType) ) ;
	if ( pRecipient == NULL ) {
		logAlert( ALERT_MESSAGE_MALLOC_NULL, __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	if ( argv[0] == NULL ) {
		pRecipient->pString = strdup( STRING_NULL_MARK ) ;
	} else {
		pRecipient->pString = strdup( argv[0] ) ;
	}
	if ( pRecipient->pString == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		free( pRecipient ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_TEMPFAIL ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: EnvRCPT=%s", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr, pRecipient->pString ) ;

	/* Insert into recipient chain */
	pRecipient->pNext = pPrivateData->envRcptList ;
	pPrivateData->envRcptList = pRecipient ;

	/* Check domain block list */
	if ( xConfData.bCheckEnvFrom && CHECKPOINT_ENVRCPT >= xConfData.iCheckOnAndAfter ) {

		if ( pPrivateData->checkResult == RC_NOTLISTED || pPrivateData->checkResult == RC_WHITELIST ) {
			pPrivateData->checkResult = checkBlockList( pPrivateData, CHECKPOINT_ENVRCPT ) ;
		}

		switch ( pPrivateData->checkResult ) {
		case RC_WHITELIST :
			vStatCount.iAccpet ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_ACCEPT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_ACCEPT ;
		case RC_BLACKLIST :
			if ( smfi_setreply( ctx, "554", "5.7.1", xConfData.sMessageReject ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iReject ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_REJECT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_REJECT ;
		case RC_GREYLIST  :
			if ( smfi_setreply( ctx, "451", "4.7.1", xConfData.sMessageTempfail ) == MI_FAILURE ) {
				logAlert( ALERT_MESSAGE_MILTER_FUNCTION, __func__, "smfi_setreply" ) ;
			}
			vStatCount.iTempfail ++ ;
			logDebug( "%s: %s [%s]: return SMFIS_TEMPFAIL", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
			return SMFIS_TEMPFAIL ;
		default :
			vStatCount.iUnmatch ++ ;
			break ;
		}

	}

	/* continue processing */
	logDebug( "%s: %s [%s]: return SMFIS_CONTINUE", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_header( SMFICTX *ctx, char *headerf, char *headerv )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	pPrivateData->bHeaderStart = TRUE ;

	/* Check domain block list */
	if ( xConfData.bCheckEnvFrom && CHECKPOINT_HEADER >= xConfData.iCheckOnAndAfter ) {

		if ( pPrivateData->checkResult == RC_NOTLISTED || pPrivateData->checkResult == RC_WHITELIST ) {
			pPrivateData->checkResult = checkBlockList( pPrivateData, CHECKPOINT_HEADER ) ;
		}

		pPrivateData->bHeaderStart = TRUE ;

		switch ( pPrivateData->checkResult ) {
		case RC_WHITELIST :
			vStatCount.iAccpet ++ ;
			return SMFIS_ACCEPT ;
		case RC_BLACKLIST :
			vStatCount.iReject ++ ;
			return SMFIS_REJECT ;
		case RC_GREYLIST  :
			vStatCount.iTempfail ++ ;
			return SMFIS_TEMPFAIL ;
		default :
			vStatCount.iUnmatch ++ ;
			break ;
		}

	}

	/* continue processing */
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_eoh( SMFICTX *ctx )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: End of header", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;

	switch ( pPrivateData->checkResult ) {
	case RC_WHITELIST :
		vStatCount.iAccpet ++ ;
		logDebug( "%s: %s [%s]: return SMFIS_ACCEPT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
		return SMFIS_ACCEPT ;
	case RC_BLACKLIST :
		vStatCount.iReject ++ ;
		logDebug( "%s: %s [%s]: return SMFIS_REJECT", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
		return SMFIS_REJECT ;
	case RC_GREYLIST  :
		vStatCount.iTempfail ++ ;
		logDebug( "%s: %s [%s]: return SMFIS_TEMPFAIL", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
		return SMFIS_TEMPFAIL ;
	default :
		vStatCount.iUnmatch ++ ;
		break ;
	}

	/* continue processing */
	logDebug( "%s: %s [%s]: return SMFIS_CONTINUE", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_body( SMFICTX *ctx, unsigned char *bodyp, size_t bodylen )
{

	/* continue processing */
	return SMFIS_CONTINUE ;

}

/**************************************************************************************************/

static sfsistat
mlfi_eom( SMFICTX *ctx )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: End of message", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;

	return mlfi_cleanup( ctx ) ;

}

/**************************************************************************************************/

static sfsistat
mlfi_abort( SMFICTX *ctx )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: Connection aborted", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;

	return mlfi_cleanup( ctx ) ;

}

/**************************************************************************************************/

static sfsistat
mlfi_close( SMFICTX *ctx )
{

	privateDataType *pPrivateData ;

	pPrivateData = (privateDataType*) smfi_getpriv( ctx ) ;
	if ( pPrivateData == NULL ) {
		logDebug( "%s: smfi_getpriv( ctx ) returns NULL", __func__ ) ;
		mlfi_cleanup( ctx ) ;
		return SMFIS_CONTINUE ;
	}

	/* Log */
	logDebug( "%s: %s [%s]: Connection closed", __func__, pPrivateData->connectFrom, pPrivateData->connectAddr ) ;

	mlfi_cleanup( ctx ) ;

	return SMFIS_CONTINUE;
}

/**************************************************************************************************/

static sfsistat
mlfi_unknown( SMFICTX *ctx, const char *cmd )
{
	return SMFIS_CONTINUE;
}

/**************************************************************************************************/

static sfsistat
mlfi_data( SMFICTX *ctx )
{
	return SMFIS_CONTINUE;
}

/**************************************************************************************************/

static sfsistat
mlfi_negotiate( SMFICTX *ctx, unsigned long f0, unsigned long f1, unsigned long f2, unsigned long f3, unsigned long *pf0, unsigned long *pf1, unsigned long *pf2, unsigned long *pf3 )
{
	return SMFIS_ALL_OPTS;
}

/**************************************************************************************************/

static void
usage( char *prog )
{
	fprintf( stderr, "Usage: %s [-c ConfigFile] [-d] [-V]\n", prog ) ;
}

/**************************************************************************************************/

static int
setFileCheckInterval( const char *sInterval )
{

	if ( sInterval == NULL ) {
		return RC_ERROR ;
	} else if ( strlen( sInterval ) == 0 ) {
		return RC_ERROR ;
	} else if ( strspn( sInterval, "0123456789" ) <  strlen( sInterval ) ) {
		return RC_ERROR ;
	}

	iMinimumInterval = atoi( sInterval ) ;

	if ( iMinimumInterval < 0 || 86400 < iMinimumInterval ) {
		iMinimumInterval = 0 ;
		return RC_ERROR ;
	}

	return RC_SUCCESS ;

}

/**************************************************************************************************/

int
main( int argc, char **argv )
{

	int 	c, i, rc ;
	const	char	*args = "c:dhst:V" ;
	extern	char	*optarg;

	pid_t	pid ;
	FILE	*fp ;

	struct	passwd	*pw;

	memset( &vStatCount, 0, sizeof(vStatCount) ) ;
	bHourlyStatLog = FALSE ;

	/* Process command line options */
	while ( (c = getopt(argc, argv, args)) != -1 )
	{
		switch (c)
		{
		case 'c': /* config file */
			if ( optarg == NULL || *optarg == '\0' ) {
				fprintf( stderr, "Illegal -c: %s\n", optarg ) ;
				exit( EX_USAGE ) ;
			}
			sConfFile = strdup( optarg ) ;
			if ( sConfFile == NULL ) {
				logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
				exit( EX_UNAVAILABLE ) ;
			}
			break;

		case 'd': /* debug, verbose, non-daemon */
			bDaemon = FALSE ;
			setLogLevel( 1 ) ;
			break;

		case 's': /* Hourly statistics log */
			bHourlyStatLog = TRUE ;
			break;

		case 't': /* Minimum interval of checking domain list update */
			if ( optarg == NULL || *optarg == '\0' ) {
				fprintf( stderr, "Illegal -t: %s\n", optarg ) ;
				exit( EX_USAGE ) ;
			}
			rc = setFileCheckInterval( optarg ) ;
			if ( rc == RC_ERROR ) {
				fprintf( stderr, "Illegal -t: %s\n", optarg ) ;
				exit( EX_USAGE ) ;
			}
			break;

		case 'V': /* Version number*/
			fprintf( stderr, "%s %s\n", PROGRAM_NAME, PROGRAM_VERSION ) ;
			exit( EX_USAGE ) ;

		case 'h':
		default:
			usage(argv[0]);
			exit( EX_USAGE ) ;
		}
	}

	initConf() ;

	openSyslog( PROGRAM_NAME, xConfData.pSyslogFacility ) ;

	logInfo( INFO_MESSAGE_PROGRAM_VERSION, PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DATE, BUILD_TIMESTAMP ) ;
	logInfo( "Minimum file update check interval=%d", iMinimumInterval ) ;

	rc = LoadConf( sConfFile ) ;
	if ( rc != 0 ) {
		logError( "Abort" ) ;
		exit( EX_CONFIG ) ;
	}

	setSyslogDebug( xConfData.bSyslogDebug ) ;

	rc = LoadAllDomainList() ;
	if ( rc != 0 ) {
		logError( "Abort" ) ;
		freeConf() ;
		exit( EX_DATAERR ) ;
	}

	/* Daemon */

	if ( bDaemon ) {
		rc = daemon( 0, 0 ) ;
		if ( rc != 0 ) {
			logAlert( ALERT_MESSAGE_DAEMON ) ;
			freeAllDomainList() ;
			freeConf() ;
			exit( EX_UNAVAILABLE ) ;
		}
	}

	/* pid file */

	pid = getpid() ;
	logDebug( "%s: pid=[%d]", __func__, pid ) ;

	if ( xConfData.sPidFile != NULL ) {
		fp = fopen( xConfData.sPidFile, "w" ) ;
		if ( fp == NULL ) {
			logError( ERROR_MESSAGE_FILE_OPEN, xConfData.sPidFile ) ;
			freeAllDomainList() ;
			freeConf() ;
			exit( EX_UNAVAILABLE ) ;
		}
		fprintf( fp, "%d\n", pid ) ;
		fclose( fp ) ;
	}

	/* Set user */

	if ( xConfData.sUser != NULL ) {

		pw = getpwnam( xConfData.sUser ) ;
		if ( pw == NULL ) {
			logError( ERROR_MESSAGE_GETPWNAM, xConfData.sUser ) ;
			freeAllDomainList() ;
			freeConf() ;
			exit( EX_UNAVAILABLE ) ;
		}
		logDebug( "%s: user=%s uid=%d gid=%d", __func__, xConfData.sUser, pw->pw_uid, pw->pw_gid ) ;

		/* Change pid file owner */

		if ( xConfData.sPidFile != NULL ) {
			rc = chown( xConfData.sPidFile, pw->pw_uid, pw->pw_gid ) ;
			if ( rc != 0 ) {
				logError( ERROR_MESSAGE_CHOWN, xConfData.sUser, pw->pw_uid, pw->pw_gid ) ;
				freeAllDomainList() ;
			freeConf() ;
				exit( EX_UNAVAILABLE ) ;
			}
		}

		/* Change user and group */

		rc = setgid( pw->pw_gid ) ;
		if ( rc != 0 ) {
			logError( ERROR_MESSAGE_SETGID, xConfData.sUser, pw->pw_gid ) ;
			freeAllDomainList() ;
			freeConf() ;
			exit( EX_UNAVAILABLE ) ;
		}

		rc = setuid( pw->pw_uid ) ;
		if ( rc != 0 ) {
			logError( ERROR_MESSAGE_SETUID, xConfData.sUser, pw->pw_uid ) ;
			freeAllDomainList() ;
			freeConf() ;
			exit( EX_UNAVAILABLE ) ;
		}

	}

	/* Start milter */

	rc = smfi_setconn( xConfData.sSocket ) ;
	if ( rc != 0 ) {
		logAlert( ALERT_MESSAGE_SOCKET_ERROR, __func__, xConfData.sSocket ) ;
		freeAllDomainList() ;
		freeConf() ;
		exit( EX_UNAVAILABLE ) ;
	}

	if ( smfi_register( smfilter ) == MI_FAILURE ) {
		fprintf(stderr, "smfi_register failed\n");
		freeAllDomainList() ;
		freeConf() ;
		exit( EX_UNAVAILABLE ) ;
	}

	rc = smfi_main() ;

	/* Terminate milter */

	freeAllDomainList() ;

	if ( xConfData.sSocket != NULL ) {
		i = 0 ;
		if ( strncmp( xConfData.sSocket, "unix:", 5) == 0 ) i = 5 ;
		else if ( strncmp( xConfData.sSocket, "local:", 6) == 0 ) i = 6 ;
		logDebug( "%s: unlink( %s )", __func__, xConfData.sSocket + i ) ;
		rc = unlink( xConfData.sSocket + i ) ;
		if ( rc != 0 ) {
			logError( ERROR_MESSAGE_FILE_UNLINK, xConfData.sSocket + i ) ;
		}
	}

	if ( xConfData.sPidFile != NULL ) {
		logDebug( "%s: unlink( %s )", __func__, xConfData.sPidFile ) ;
		rc = unlink( xConfData.sPidFile ) ;
		if ( rc != 0 ) {
			logError( ERROR_MESSAGE_FILE_UNLINK, xConfData.sPidFile ) ;
			fp = fopen( xConfData.sPidFile, "w" ) ;
			if ( fp != NULL ) fclose( fp ) ;
		}
	}

	logInfo( INFO_MESSAGE_STOP ) ;

	freeConf() ;

	return rc ;

}

/**************************************************************************************************/
