/******************************************************************************/
/*                                                                            */
/*  Copyright(C) 2016, Takao Abe.  All rights reserved.                       */
/*                                                                            */
/*  LICENSE: GPLv3 or any later version                                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  ChangeLog                                                                 */
/*                                                                            */
/*  2016/05/21  1.00                                                          */
/*      First release                                                         */
/*                                                                            */
/*  2016/07/02  1.01                                                          */
/*      [Enhancement] Support GNU build procedure.                            */
/*                    Add config.h generated by the Autoconf/Automake.        */
/*      [Enhancement] Conf file new keyword 'syslogDebug'.                    */
/*                    Optional writing syslog priority=debug.                 */
/*      [Enhancement] Conf file new keyword 'checkMacro_'.                    */
/*                    Check value of the sendmail macro '_'.                  */
/*                                                                            */
/*  2016/11/03  1.02                                                          */
/*      [Bug fix] Lost the first entry of unsorted domain list.               */
/*                Patched: blkdom_config.c - addDomain                        */
/*                                                                            */
/*  2017/12/23  1.03                                                          */
/*      [Bug fix] Avoid multiple reloading domain lists in race conditions.   */
/*                blkdom_config.c - initConf, ReloadAllDomainList             */
/*                                                                            */
/*  2018/01/14  1.04                                                          */
/*      [Change] Change leaf node anchors have every two characters of the    */
/*               beginning of the domain node name, from they have every one  */
/*               character of the beginning of the domain node name.          */
/*               milter-blockdomain.h  blkdom_check.c  blkdom_config.c        */
/*      [Change] Add following statistics information,                        */
/*               Node/Leaf count, Node/Leaf average chain length.             */
/*               milter-blockdomain.h - domainListType                        */
/*               blkdom_config.c - statDomainList, LoadDomainList             */
/*                                                                            */
/******************************************************************************/

#include "config.h"	/* GNU Autotools */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>
#include <sys/time.h>

#include "milter-blockdomain.h"

/* Config Keywords */

#define CONF_USER             "user"
#define CONF_SOCKET           "socket"
#define CONF_PIDFILE          "pidFile"
#define CONF_SUBDOMAIN        "Subdomain"
#define CONF_CHECK_CONNECT    "checkConnect"
#define CONF_CHECK_MACRO_     "checkMacro_"
#define CONF_CHECK_HELO       "checkHelo"
#define CONF_CHECK_ENVFROM    "checkEnvFrom"
#define CONF_CHECK_ENVRCPT    "checkEnvRcpt"
#define CONF_CHECK_ONANDAFTER "checkOnAndAfter"
#define CONF_MESSAGE_TEMPFAIL "messageTempfail"
#define CONF_MESSAGE_REJECT   "messageReject"
#define CONF_SYSLOG_FACILITY  "syslogFacility"
#define CONF_SYSLOG_DEBUG     "syslogDebug"
#define CONF_WHITELIST        "whitelist"
#define CONF_BLACKLIST        "blacklist"
#define CONF_GREYLIST         "greylist"

#define CONF_TESTMODE         "testMode"

#define CONF_DEBUG_CONFIG_FUNCTION	"debugConfigFunction"
#define CONF_DEBUG_CHECK_FUNCTION	"debugCheckFunction"

/* Global data */

confType xConfData ;
domainListType	xDomainList[ MAX_DOMAIN_LIST ] ;

/* Local data */

static	char	bReloadingDomainList ;

/**************************************************************************************************/

void initConf()
{

	memset( &xConfData, 0, sizeof(confType) ) ;

	xConfData.bSubdomain       = TRUE ;
	xConfData.bCheckConnect    = TRUE ;
	xConfData.bCheckMacro_     = TRUE ;
	xConfData.bCheckHelo       = TRUE ;
	xConfData.bCheckEnvFrom    = TRUE ;
	xConfData.bCheckEnvRcpt    = TRUE ;
	xConfData.iCheckOnAndAfter = 3 ;

	xConfData.bSyslogDebug = FALSE ;

	xConfData.bTestMode = FALSE ;

	xConfData.bDebugConfigFunction = FALSE ;
	xConfData.bDebugCheckFunction  = FALSE ;

	bReloadingDomainList = FALSE ;

}

/**************************************************************************************************/

void freeConf()
{

	if ( xConfData.sUser            != NULL ) free( xConfData.sUser            ) ;
	if ( xConfData.sSocket          != NULL ) free( xConfData.sSocket          ) ;
	if ( xConfData.sPidFile         != NULL ) free( xConfData.sPidFile         ) ;
	if ( xConfData.sMessageTempfail != NULL ) free( xConfData.sMessageTempfail ) ;
	if ( xConfData.sMessageReject   != NULL ) free( xConfData.sMessageReject   ) ;
	if ( xConfData.pSyslogFacility  != NULL ) free( xConfData.pSyslogFacility  ) ;

}

/**************************************************************************************************/

static int getTrueFalse( const char *sValue )
{

	if ( sValue == NULL ) return -1 ;
	if ( strlen( sValue ) != 1 ) return -1 ;
	switch ( *sValue ) {
	case '0' : return 0 ;
	case '1' : return 1 ;
	}
	return -1 ;

}

/**************************************************************************************************/

int LoadConf( const char *sConfFile )
{

	FILE	*fp ;
	char	sLine[ MAX_CONF_LINE_LENGTH ] ;
	char	*sToken[ 4 ], *sValue[ 4 ] ;
	int 	iLineNumber = 0, iListCount = 0 ;
	int 	iValue ;
	int 	iConfigError = 0 ;
	int 	i ;

	logInfo( INFO_MESSAGE_CONFIG, sConfFile ) ;

	fp = fopen( sConfFile, "r" ) ;
	if ( fp == NULL ) {
		logError( ERROR_MESSAGE_FILE_OPEN, sConfFile ) ;
		return RC_ERROR ;
	}

	while ( fgets( sLine, sizeof(sLine)-1, fp ) != NULL ) {

		iLineNumber ++ ;
		sLine[sizeof(sLine)-1] = 0 ;

		/* LF -> \0 */
		strtok( sLine, "\n" ) ;

		/* First token */
		sToken[0] = strtok( sLine, " =\n" ) ;

		/* Skip comment line */
		if ( sToken[0] == NULL ) continue ;
		else if ( *(sToken[0]) == '#' ) continue ;

		/* Second token */
		if ( strcmp( sToken[0], CONF_MESSAGE_TEMPFAIL ) == 0
		  || strcmp( sToken[0], CONF_MESSAGE_REJECT   ) == 0 ) {
			sToken[1] = strtok( NULL, "\n" ) ;
			if ( sToken[1] != NULL) {
				while ( *(sToken[1]) == ' ' || *(sToken[1]) == '=' ) sToken[1] ++ ;
			}
			sToken[1] = strtok( sToken[1], "\"\n" ) ;
		} else {
			sToken[1] = strtok( NULL, " =\n" ) ;
		}

		if ( sToken[1] == NULL ) {
			iConfigError ++ ;
			logError( ERROR_MESSAGE_INVALID_CONFIG_MISSING_1, iLineNumber, sToken[0] ) ;
			continue ;
		} else if ( *(sToken[1]) == 0 ) {
			iConfigError ++ ;
			logError( ERROR_MESSAGE_INVALID_CONFIG_MISSING_1, iLineNumber, sToken[0] ) ;
			continue ;
		}

		/* Copy second token */
		sValue[1] = strdup( sToken[1] ) ;
		if ( sValue[1] == NULL ) {
			logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
			fclose( fp ) ;
			return RC_ERROR ;
		}

		logDebug( "%s: [%s] [%s]", __func__, sToken[0], sToken[1] ) ;

		if ( strcmp( sToken[0], CONF_USER ) == 0 ) {
			xConfData.sUser = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_SOCKET ) == 0 ) {
			xConfData.sSocket = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_PIDFILE ) == 0 ) {
			xConfData.sPidFile = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_SUBDOMAIN ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bSubdomain = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bSubdomain = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_CONNECT ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bCheckConnect = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bCheckConnect = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_MACRO_ ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bCheckMacro_ = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bCheckMacro_ = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_HELO ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bCheckHelo = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bCheckHelo = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_ENVFROM ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bCheckEnvFrom = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bCheckEnvFrom = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_ENVRCPT ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bCheckEnvRcpt = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bCheckEnvRcpt = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_CHECK_ONANDAFTER ) == 0 ) {
			free( sValue[1] ) ;
			if ( strlen( sToken[1] ) == 1 && isdigit( *(sToken[1]) ) ) {
				xConfData.iCheckOnAndAfter = atoi( sToken[1] ) ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_MESSAGE_TEMPFAIL ) == 0 ) {
			xConfData.sMessageTempfail = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_MESSAGE_REJECT ) == 0 ) {
			xConfData.sMessageReject = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_SYSLOG_FACILITY ) == 0 ) {
			xConfData.pSyslogFacility = sValue[1] ;

		} else if ( strcmp( sToken[0], CONF_SYSLOG_DEBUG ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bSyslogDebug = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bSyslogDebug = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_WHITELIST ) == 0 ) {
			if ( iListCount < MAX_DOMAIN_LIST ) {
				xDomainList[iListCount].sFileName = sValue[1] ;
				xDomainList[iListCount].iListType = WHITELIST ;
				xDomainList[iListCount].oDomainRoot.pName = "." ;
				xDomainList[iListCount].oDomainRoot.iLength = 1 ;
				xDomainList[iListCount].oDomainRoot.iLevel = 0 ;
				iListCount ++ ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_MAX_LIST, iLineNumber, sToken[0] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_BLACKLIST ) == 0 ) {
			if ( iListCount < MAX_DOMAIN_LIST ) {
				xDomainList[iListCount].sFileName = sValue[1] ;
				xDomainList[iListCount].iListType = BLACKLIST ;
				xDomainList[iListCount].oDomainRoot.pName = "." ;
				xDomainList[iListCount].oDomainRoot.iLength = 1 ;
				xDomainList[iListCount].oDomainRoot.iLevel = 0 ;
				iListCount ++ ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_MAX_LIST, iLineNumber, sToken[0] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_GREYLIST ) == 0 ) {
			if ( iListCount < MAX_DOMAIN_LIST ) {
				xDomainList[iListCount].sFileName = sValue[1] ;
				xDomainList[iListCount].iListType = GREYLIST ;
				xDomainList[iListCount].oDomainRoot.pName = "." ;
				xDomainList[iListCount].oDomainRoot.iLength = 1 ;
				xDomainList[iListCount].oDomainRoot.iLevel = 0 ;
				iListCount ++ ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_MAX_LIST, iLineNumber, sToken[0] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_TESTMODE ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bTestMode = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bTestMode = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_DEBUG_CONFIG_FUNCTION ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bDebugConfigFunction = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bDebugConfigFunction = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else if ( strcmp( sToken[0], CONF_DEBUG_CHECK_FUNCTION ) == 0 ) {
			free( sValue[1] ) ;
			iValue = getTrueFalse( sToken[1] ) ;
			if ( iValue == 0 ) {
				xConfData.bDebugCheckFunction = FALSE ;
			} else if ( iValue == 1 ) {
				xConfData.bDebugCheckFunction = TRUE ;
			} else {
				iConfigError ++ ;
				logError( ERROR_MESSAGE_INVALID_CONFIG_VALUE_1, iLineNumber, sToken[0], sToken[1] ) ;
			}

		} else {
			free( sValue[1] ) ;
			iConfigError ++ ;
			logError( ERROR_MESSAGE_INVALID_CONFIG_KEYWORD, iLineNumber, sToken[0] ) ;
		}

	}

    fclose( fp ) ;

	if ( iConfigError > 0 ) {
		logError( ERROR_MESSAGE_INVALID_CONFIG_ERROR_COUNT, iConfigError ) ;
		return RC_ERROR ;
	}

	for ( i = 0 ; i < iListCount ; i ++ ) {
		if ( xDomainList[i].sFileName == NULL ) break ;
		xDomainList[i].bSubdomain = xConfData.bSubdomain ;
	}

    return RC_SUCCESS ;

}

/**************************************************************************************************/

static int addDomain( const int iLineNumber, domainNodeType *pDomainRoot, const char *pDomain )
{

	int 	i, iDomainLevel, iFirstLetterIndex, iSecondLetterIndex ;
	char	sDomain[ MAX_DOMAIN_NAME_LENGTH + 1 ] ;
	char	*pDomainNodeName[ MAX_DOMAIN_LEVEL ] ;

	domainNodeType	*pNodeEntry, *pPreviousNodeEntry, *pParentNode ;
	domainLeafType	*pLeafEntry, *pPreviousLeafEntry ;

	if ( strcmp( pDomain, "." ) == 0 ) {
		logWarning( WARNING_MESSAGE_INVALID_DOMAINLIST_ROOTDOMAIN, iLineNumber, pDomain ) ;
		return RC_SUCCESS ;
	}

	strncpy( sDomain, pDomain, MAX_DOMAIN_NAME_LENGTH ) ;
	sDomain[MAX_DOMAIN_NAME_LENGTH] = 0 ;
	strLower( sDomain ) ;

	/* Parse domain level */
	iDomainLevel = 0 ;
	for  ( i = strlen( sDomain ) - 1 ; i >= 0 ; i -- ) {
		if ( sDomain[i] == '.' || i == 0 ) {

			if ( iDomainLevel == MAX_DOMAIN_LEVEL ) {
				logError( ERROR_MESSAGE_INVALID_DOMAINLIST_NODE_DEPTH, iLineNumber, pDomain ) ;
				return RC_ERROR ;
			}

			if ( sDomain[i] == '.' ) pDomainNodeName[iDomainLevel] = sDomain + i + 1 ;
			else                     pDomainNodeName[iDomainLevel] = sDomain + i ;

			if ( strlen( pDomainNodeName[iDomainLevel] ) == 0 ) {
				logError( ERROR_MESSAGE_INVALID_DOMAINLIST_NODE_LENGTH, iLineNumber, pDomain ) ;
				return RC_ERROR ;
			}

			iDomainLevel ++ ;
			if ( sDomain[i] == '.' ) sDomain[i] = 0 ;

		}
	}

	/* Add domain */

	pParentNode = pDomainRoot ;
	for ( i = 0 ; i < iDomainLevel - 1 ; i ++ ) {

		iFirstLetterIndex = GET_INDEX( *(pDomainNodeName[i]) ) ;

		/* Check domain node */

		pPreviousNodeEntry = pNodeEntry = pParentNode->pNodeList[iFirstLetterIndex] ;
		while ( pNodeEntry != NULL ) {
			if ( strcmp( pDomainNodeName[i], pNodeEntry->pName ) == 0 ) {
				/* Fount */
				break ;
			} else if ( strcmp( pDomainNodeName[i], pNodeEntry->pName ) < 0 ) {
				/* Not found */
				pNodeEntry = NULL ;
				break ;
			}
			pPreviousNodeEntry = pNodeEntry ;
			pNodeEntry = pNodeEntry->pNext ;
		}

		if ( pNodeEntry != NULL ) {
			pParentNode = pNodeEntry ;
			continue ;
		}

		/* Add domain node */

		pNodeEntry = malloc( sizeof(domainNodeType) ) ;
		if ( pNodeEntry == NULL ) {
			logAlert( ALERT_MESSAGE_MALLOC_NULL, __func__ ) ;
			return RC_ERROR ;
		}
		memset( pNodeEntry, 0, sizeof(domainNodeType) ) ;

		pNodeEntry->pName = strdup( pDomainNodeName[i] ) ;
		if ( pNodeEntry == NULL ) {
			logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
			return RC_ERROR ;
		}
		pNodeEntry->iLength = strlen( pNodeEntry->pName ) ;
		pNodeEntry->iLevel = i + 1 ;

		if ( xConfData.bDebugConfigFunction ) {
			logDebug( "%s: Level=%d Node Index=%d: %s (Add)", __func__, pNodeEntry->iLevel, iFirstLetterIndex, pNodeEntry->pName ) ;
		}

		if ( pPreviousNodeEntry == NULL ) {
			pNodeEntry->pNext = NULL ;
			pParentNode->pNodeList[iFirstLetterIndex] = pNodeEntry ;
		} else {
			pNodeEntry->pNext = pPreviousNodeEntry->pNext ;
			pPreviousNodeEntry->pNext = pNodeEntry ;
		}

		pParentNode = pNodeEntry ;

	}

	/* Check domain leaf */

	iFirstLetterIndex = GET_INDEX( *(pDomainNodeName[i]) ) ;
	iSecondLetterIndex = GET_INDEX( *(pDomainNodeName[i]+1) ) ;

	pPreviousLeafEntry = pLeafEntry = pParentNode->pLeafList[iFirstLetterIndex][iSecondLetterIndex] ;
	while ( pLeafEntry != NULL ) {
		if ( strcmp( pDomainNodeName[i], pLeafEntry->pName ) == 0 ) {
			/* Found */
			break ;
		} else if ( strcmp( pDomainNodeName[i], pLeafEntry->pName ) < 0 ) {
			/* Not found */
			pLeafEntry = NULL ;
			break ;
		}
		pPreviousLeafEntry = pLeafEntry ;
		pLeafEntry = pLeafEntry->pNext ;
	}

	if ( pLeafEntry != NULL ) {
		logWarning( WARNING_MESSAGE_INVALID_DOMAINLIST_DUPLICATE, iLineNumber, pDomain ) ;
		return RC_SUCCESS ;
	}

	/* Add domain leaf */

	pLeafEntry = malloc( sizeof(domainLeafType) ) ;
	if ( pLeafEntry == NULL ) {
		logAlert( ALERT_MESSAGE_MALLOC_NULL, __func__ ) ;
		return RC_ERROR ;
	}
	memset( pLeafEntry, 0, sizeof(domainLeafType) ) ;

	pLeafEntry->pName = strdup( pDomainNodeName[i] ) ;
	if ( pLeafEntry == NULL ) {
		logAlert( ALERT_MESSAGE_STRDUP_NULL, __func__ ) ;
		return RC_ERROR ;
	}
	pLeafEntry->iLength = strlen( pLeafEntry->pName ) ;

	if ( xConfData.bDebugConfigFunction ) {
		logDebug( "%s: Level=%d Leaf Index=%d,%d: %s (Add)", __func__, pParentNode->iLevel + 1, iFirstLetterIndex, iSecondLetterIndex, pLeafEntry->pName ) ;
	}

	if ( pPreviousLeafEntry == NULL ) {
		pLeafEntry->pNext = NULL ;
		pParentNode->pLeafList[iFirstLetterIndex][iSecondLetterIndex] = pLeafEntry ;
	} else {
		pLeafEntry->pNext = pPreviousLeafEntry->pNext ;
		pPreviousLeafEntry->pNext = pLeafEntry ;
	}

	return RC_SUCCESS ;

}

/**************************************************************************************************/

static void statDomainList( domainListType *pDomainList, domainNodeType *pParentNode )
{

	int 	i, j ;
	domainLeafType	*pLeafEntry ;
	domainNodeType	*pNodeEntry ;
	int 	iLeafChainCount, iNodeChainCount ;

	if ( strcmp( pParentNode->pName, "." ) == 0 || pParentNode->iLevel == 0 ) {
		pDomainList->iStatTotal = 0 ;
		pDomainList->iStatTLD = 0 ;
		pDomainList->iStatDepth = 0 ;
		pDomainList->iStatMaxLeafChain = 0 ;
		pDomainList->iStatMaxNodeChain = 0 ;
		pDomainList->iStatNumberOfLeafAnchors = 0 ;
		pDomainList->iStatNumberOfNodeAnchors = 0 ;
		pDomainList->iStatTotalLeafChain = 0 ;
		pDomainList->iStatTotalNodeChain = 0 ;
		pDomainList->iStatAverageLeafChain = 0 ;
		pDomainList->iStatAverageNodeChain = 0 ;
		if ( xConfData.bDebugConfigFunction ) {
			logDebug( "%s: Level=%d Node=%s Initialize statistics", __func__, pParentNode->iLevel, pParentNode->pName ) ;
		}
	}

	for ( i = 0 ; i < MAX_DOMAIN_INDEX ; i ++ ) {
		for ( j = 0 ; j < MAX_DOMAIN_INDEX ; j ++ ) {

			if ( pParentNode->pLeafList[i][j] != NULL ) pDomainList->iStatNumberOfLeafAnchors ++ ;

			if ( pParentNode->pLeafList[i][j] != NULL
			  && pDomainList->iStatDepth < pParentNode->iLevel + 1 ) {
				pDomainList->iStatDepth = pParentNode->iLevel + 1 ;
			}

			iLeafChainCount = 0 ;
			pLeafEntry = pParentNode->pLeafList[i][j] ;
			while ( pLeafEntry != NULL ) {
				iLeafChainCount ++ ;
				pDomainList->iStatTotal ++ ;
				if ( strcmp( pParentNode->pName, "." ) == 0 || pParentNode->iLevel == 0 ) {
					pDomainList->iStatTLD ++ ;
				}
				pLeafEntry = pLeafEntry->pNext ;
			}

			pDomainList->iStatTotalLeafChain += iLeafChainCount ;
			if ( pDomainList->iStatMaxLeafChain < iLeafChainCount ) pDomainList->iStatMaxLeafChain = iLeafChainCount ;

		}
	}

	if ( pDomainList->iStatNumberOfLeafAnchors > 0 ) pDomainList->iStatAverageLeafChain = pDomainList->iStatTotalLeafChain / pDomainList->iStatNumberOfLeafAnchors ;

	for ( i = 0 ; i < MAX_DOMAIN_INDEX ; i ++ ) {

		if ( pParentNode->pNodeList[i] != NULL ) pDomainList->iStatNumberOfNodeAnchors ++ ;

		if ( pParentNode->pNodeList[i] != NULL
		  && pDomainList->iStatDepth < pParentNode->iLevel + 1 ) {
			pDomainList->iStatDepth = pParentNode->iLevel + 1 ;
		}

		iNodeChainCount = 0 ;
		pNodeEntry = pParentNode->pNodeList[i] ;
		while ( pNodeEntry != NULL ) {
			iNodeChainCount ++ ;
			if ( strcmp( pParentNode->pName, "." ) == 0 || pParentNode->iLevel == 0 ) {
				pDomainList->iStatTLD ++ ;
			}
			statDomainList( pDomainList, pNodeEntry ) ;
			pNodeEntry = pNodeEntry->pNext ;
		}

		pDomainList->iStatTotalNodeChain += iNodeChainCount ;
		if ( pDomainList->iStatMaxNodeChain < iNodeChainCount ) pDomainList->iStatMaxNodeChain = iNodeChainCount ;

	}

	if ( pDomainList->iStatNumberOfNodeAnchors > 0 ) pDomainList->iStatAverageNodeChain = pDomainList->iStatTotalNodeChain / pDomainList->iStatNumberOfNodeAnchors ;

	if ( xConfData.bDebugConfigFunction ) {
		logDebug( "%s: Level=%d Node=%s NodeIndex=%d, TotalNodeChain=%d MaxNodeChain=%d, AverageNodeChain=%d, LeafIndex=%d, TotalLeafChain=%d MaxLeafChain=%d, AverageLeafChain=%d",
		          __func__, pParentNode->iLevel, pParentNode->pName,
		          pDomainList->iStatNumberOfNodeAnchors, pDomainList->iStatTotalNodeChain, pDomainList->iStatMaxNodeChain, pDomainList->iStatAverageNodeChain,
		          pDomainList->iStatNumberOfLeafAnchors, pDomainList->iStatTotalLeafChain, pDomainList->iStatMaxLeafChain, pDomainList->iStatAverageLeafChain ) ;
	}

}

/**************************************************************************************************/

static int LoadDomainList( domainListType *pDomainList )
{

	int 	rc ;
	FILE	*fp ;
	struct	stat	currentStat ;
	int 	iLineNumber = 0 ;
	char	sLine[ MAX_DOMAIN_NAME_LENGTH + 1 ] ;
	char	*pToken ;

	struct	timeval	tStart, tFinish ;
	double	dElapseTime ;

	logInfo( "Loading %s", pDomainList->sFileName ) ;

	gettimeofday( &tStart, NULL ) ;

	fp = fopen( pDomainList->sFileName, "r" ) ;
	if ( fp == NULL ) {
		logError( ERROR_MESSAGE_FILE_OPEN, pDomainList->sFileName ) ;
		return RC_ERROR ;
	}

	while ( fgets( sLine, sizeof(sLine)-1, fp ) != NULL ) {

		iLineNumber ++ ;
		sLine[sizeof(sLine)-1] = 0 ;

		pToken = strtok( sLine, " \n" ) ;

		/* Skip comment line */
		if ( pToken == NULL ) continue ;
		else if ( *(pToken) == '#' ) continue ;

		/* Add domain to domain list */
		rc = addDomain( iLineNumber, &(pDomainList->oDomainRoot), pToken ) ;
		if ( rc == RC_ERROR ) {
			fclose( fp ) ;
			return RC_ERROR ;
		}

	}

	fclose( fp ) ;

	/* Domain list timestamp */

	rc = stat( pDomainList->sFileName, &currentStat ) ;
	if ( rc != 0 ) {
		logError( ERROR_MESSAGE_FILE_STAT, xDomainList->sFileName ) ;
		return RC_ERROR ;
	}

	pDomainList->xFileStat.st_size  = currentStat.st_size ;
	pDomainList->xFileStat.st_mtime = currentStat.st_mtime ;

	/* Statistic of domain list */

	statDomainList( pDomainList, &(pDomainList->oDomainRoot) ) ;

	gettimeofday( &tFinish, NULL ) ;
	dElapseTime = (double)(tFinish.tv_sec) + (double)(tFinish.tv_usec) * 0.000001
	            - (double)(tStart.tv_sec)  - (double)(tStart.tv_usec)  * 0.000001 ;

	logInfo( "Loaded successfully in %.3lfs: Total=%d, TLD=%d, Depth=%d, NodeIndex=%d, MaxNodeChain=%d, AverageNodeChain=%d, LeafIndex=%d, MaxLeafChain=%d, AverageLeafChain=%d",
	         dElapseTime,
	         pDomainList->iStatTotal, pDomainList->iStatTLD, pDomainList->iStatDepth,
	         pDomainList->iStatNumberOfNodeAnchors, pDomainList->iStatMaxNodeChain, pDomainList->iStatAverageNodeChain,
	         pDomainList->iStatNumberOfLeafAnchors, pDomainList->iStatMaxLeafChain, pDomainList->iStatAverageLeafChain ) ;

	return RC_SUCCESS ;

}

/**************************************************************************************************/

static void freeDomainList( domainNodeType *pParentNode )
{

	int 	i, j ;
	domainLeafType	*pLeafEntry ;
	domainNodeType	*pNodeEntry ;

	for ( i = 0 ; i < MAX_DOMAIN_INDEX ; i ++ ) {

		while ( pParentNode->pNodeList[i] != NULL ) {
			pNodeEntry = pParentNode->pNodeList[i] ;
			pParentNode->pNodeList[i] = pNodeEntry->pNext ;
			freeDomainList( pNodeEntry ) ;
		}

	}

	for ( i = 0 ; i < MAX_DOMAIN_INDEX ; i ++ ) {
		for ( j = 0 ; j < MAX_DOMAIN_INDEX ; j ++ ) {

			while ( pParentNode->pLeafList[i][j] != NULL ) {
				pLeafEntry = pParentNode->pLeafList[i][j] ;
				pParentNode->pLeafList[i][j] = pLeafEntry->pNext ;
				if ( xConfData.bDebugConfigFunction ) {
					logDebug( "%s: Level=%d (Leaf) %s", __func__, pParentNode->iLevel + 1, pLeafEntry->pName ) ;
				}
				free( pLeafEntry ) ;
			}

		}
	}

	if ( strcmp( pParentNode->pName, "." ) != 0 || pParentNode->iLevel != 0 ) {
		if ( xConfData.bDebugConfigFunction ) {
			logDebug( "%s: Level=%d (Node) %s", __func__, pParentNode->iLevel, pParentNode->pName ) ;
		}
		free( pParentNode->pName ) ;
		free( pParentNode ) ;
	}

}

/**************************************************************************************************/

int LoadAllDomainList()
{

	int 	i, rc ;

	for ( i = 0 ; i < MAX_DOMAIN_LIST ; i ++ ) {
		if ( xDomainList[i].sFileName == NULL ) break ;

		rc = LoadDomainList( &(xDomainList[i]) ) ;
		if ( rc == RC_ERROR ) return rc ;

	}

	return RC_SUCCESS ;

}

/**************************************************************************************************/

int ReloadAllDomainList()
{

	int 	i, rc ;
	struct  stat	currentStat ;

	if ( bReloadingDomainList ) {
		return RC_ERROR ;
	}

	bReloadingDomainList = TRUE ;

	for ( i = 0 ; i < MAX_DOMAIN_LIST ; i ++ ) {
		if ( xDomainList[i].sFileName == NULL ) break ;

		rc = stat( xDomainList[i].sFileName, &currentStat ) ;
		if ( rc != 0 ) {
			logError( ERROR_MESSAGE_FILE_STAT, xDomainList[i].sFileName ) ;
			continue ;
		}

		if ( xDomainList[i].xFileStat.st_size  == currentStat.st_size
		  && xDomainList[i].xFileStat.st_mtime == currentStat.st_mtime ) {
			continue ;
		}

		freeDomainList( &(xDomainList[i].oDomainRoot) ) ;

		rc = LoadDomainList( &(xDomainList[i]) ) ;
		if ( rc == RC_ERROR ) {
			bReloadingDomainList = FALSE ;
			return rc ;
		}

	}

	bReloadingDomainList = FALSE ;

	return RC_SUCCESS ;

}

/**************************************************************************************************/

void freeAllDomainList()
{

	int 	i ;

	for ( i = 0 ; i < MAX_DOMAIN_LIST ; i ++ ) {
		if ( xDomainList[i].sFileName == NULL ) break ;

		logDebug( "%s: %s", __func__, xDomainList[i].sFileName ) ;

		freeDomainList( &(xDomainList[i].oDomainRoot) ) ;

	}

}

/**************************************************************************************************/
